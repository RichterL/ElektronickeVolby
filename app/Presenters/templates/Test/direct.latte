<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Testing key</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <script src="/js/crypto/jsbn.js"></script>
  <script src="/js/crypto/jsbn2.js"></script>
  <script src="/js/crypto/secure-random.js"></script>
  <script src="/js/crypto/js-sha256@latest.js"></script>
  <script src="/js/crypto/rsa.js"></script>

	<script>
	async function digestMessage(message) {
  const encoder = new TextEncoder();
  const data = encoder.encode(message);
  const hash = await crypto.subtle.digest('SHA-256', data);
  return hash;
}

function messageToHash(message) {
  const messageHash = jsSha256(message);
  console.log("hash: " + messageHash);
  return messageHash;
}

function messageToHashInt(message) {
  const messageHash = messageToHash(message);
  const messageBig = new BigInteger(messageHash, 16);
  return messageBig;
}

function blind({ message, key, N, E }) {
  const messageHash = messageToHashInt(message);
  console.log("messageHashInt: " + messageHash.toString());
  N = key ? key.keyPair.n : new BigInteger(N.toString());
  E = key
    ? new BigInteger(key.keyPair.e.toString())
    : new BigInteger(E.toString());

  const bigOne = new BigInteger('1');
  let gcd;
  let r;
  do {
    r = new BigInteger(secureRandom(64)).mod(N);
    gcd = r.gcd(N);
  } while (
    !gcd.equals(bigOne) ||
    r.compareTo(N) >= 0 ||
    r.compareTo(bigOne) <= 0
  );
  const blinded = messageHash.multiply(r.modPow(E, N)).mod(N);
  return {
    blinded,
    r,
  };
}

function unblind({ signed, key, r, N }) {
  r = new BigInteger(r.toString());
  N = key ? key.keyPair.n : new BigInteger(N.toString());
  signed = new BigInteger(signed.toString());
  const unblinded = signed.multiply(r.modInverse(N)).mod(N);
  return unblinded;
}

	// Example POST method implementation:
async function postData(url = '', data = {}) {
  // Default options are marked with *
  const response = await fetch(url, {
    method: 'POST', // *GET, POST, PUT, DELETE, etc.
    mode: 'cors', // no-cors, *cors, same-origin
    cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
    credentials: 'same-origin', // include, *same-origin, omit
    headers: {
      'Content-Type': 'application/json'
      // 'Content-Type': 'application/x-www-form-urlencoded',
    },
    redirect: 'follow', // manual, *follow, error
    referrerPolicy: 'no-referrer', // no-referrer, *no-referrer-when-downgrade, origin, origin-when-cross-origin, same-origin, strict-origin, strict-origin-when-cross-origin, unsafe-url
    body: JSON.stringify(data) // body data type must match "Content-Type" header
  });
  return response.json(); // parses JSON response into native JavaScript objects
}

function removeLines(str) {
    return str.replace("\n", "");
}

function base64ToArrayBuffer(b64) {
    var byteString = window.atob(b64);
    var byteArray = new Uint8Array(byteString.length);
    for(var i=0; i < byteString.length; i++) {
        byteArray[i] = byteString.charCodeAt(i);
    }

    return byteArray;
}

function strToArrayBuffer(str) {
  var buf = new ArrayBuffer(str.length * 2);
  var bufView = new Uint16Array(buf);
  for (var i = 0, strLen = str.length; i < strLen; i++) {
    bufView[i] = str.charCodeAt(i);
  }
  console.log("bufView")
  console.log(bufView)
  return buf;
}
function arrayBufferToString(buf) {
  return String.fromCharCode.apply(null, new Uint16Array(buf));
}

  // from https://developers.google.com/web/updates/2012/06/How-to-convert-ArrayBuffer-to-and-from-String
  function str2ab(str) {
    const buf = new ArrayBuffer(str.length);
    const bufView = new Uint8Array(buf);
    for (let i = 0, strLen = str.length; i < strLen; i++) {
      bufView[i] = str.charCodeAt(i);
    }
    return buf;
  }

  function importRsaKey(pem) {
    // fetch the part of the PEM string between header and footer
    const pemHeader = "-----BEGIN PUBLIC KEY-----";
    const pemFooter = "-----END PUBLIC KEY-----";
    const pemContents = pem.substring(pemHeader.length, pem.length - pemFooter.length);
    // base64 decode the string to get the binary data
    const binaryDerString = window.atob(pemContents);
    // convert from a binary string to an ArrayBuffer
    const binaryDer = str2ab(binaryDerString);

    return window.crypto.subtle.importKey(
      "spki",
      binaryDer,
      {
        name: "RSA-OAEP",
        hash: "SHA-256"
      },
      true,
      ["encrypt"]
    );
  }

  function importRsaPrivateKey(pem) {
    // fetch the part of the PEM string between header and footer
    const pemHeader = "-----BEGIN PRIVATE KEY-----";
    const pemFooter = "-----END PRIVATE KEY-----";
    const pemContents = pem.substring(pemHeader.length, pem.length - pemFooter.length);
    // base64 decode the string to get the binary data
    const binaryDerString = window.atob(pemContents);
    // convert from a binary string to an ArrayBuffer
    const binaryDer = str2ab(binaryDerString);

    return window.crypto.subtle.importKey(
      "spki",
      binaryDer,
      {
        name: "RSA-OAEP",
        hash: "SHA-256"
      },
      true,
      ["decrypt"]
    );
  }

var E; var N; var pubKey; var privKey;
postData({link getPublicSigningKey!})
	.then(data => {
		{* console.log(data); *}
		E = data.e;
		N = data.n;
		{* console.log('e: '+E); *}
		{* console.log('n: '+N); *}
		console.log("public key")
		console.log(data.key)
		console.log(importRsaKey(data.key))
		pubKey = data.key

		var loadedKey = RSA.getPublicKey(pubKey);
		let lipsum = `Laboris esse ad culpa pariatur aliqua. Exercitation veniam commodo magna veniam voluptate commodo deserunt in commodo tempor sit proident sit irure.`;
		var encrypted = RSA.encrypt(lipsum, loadedKey);
		postData({link decryptPKCS1!}, { 'message': encrypted }).then(data => {
			console.log('rsa.js decrypted')
			console.log(data)
		})
	})

var key;
var rawKey;
postData({link getPrivateKey!}).then(data => {
	console.log("private key");
	console.log(data);
	{* console.log(importRsaPrivateKey(data)) *}
	privKey = data
});



postData({link getPublicEncryptionKey!}).then(data => {

		var keyData =  {
				kty: "RSA",
				e: E,
				n: N,
				alg: "RSA-OAEP-256",
				ext: true,
			};

		var algo = {
			name: "RSA-OAEP",
			hash: { name: "SHA-256" },
		};

		crypto.subtle.importKey('jwk', keyData, algo, false, ['encrypt'])
		.then (function (publicKey){
			let lipsum = 'Laboris esse ad culpa pariatur aliqua. Exercitation veniam commodo magna veniam voluptate commodo deserunt in commodo tempor sit proident sit irure.';
			let data =  strToArrayBuffer(lipsum);
			console.log("strToArrayBuffer('Hello World!');");
			console.log(data)
			let revData = arrayBufferToString(data);
			console.log("revData")
			console.log(revData)
			console.log('before encrypt')
			window.crypto.subtle.encrypt(
				{
					name: "RSA-OAEP",
					//label: Uint8Array([...]) //optional
				},
				publicKey, //from generateKey or importKey above
				data //ArrayBuffer of data you want to encrypt
			)
			.then(function(encrypted){
				//returns an ArrayBuffer containing the encrypted data
				console.log("encrypted");
				console.log(encrypted);
				console.log("arrayBufferToString(encrypted)")
				console.log(arrayBufferToString(encrypted))
				console.log("new Uint8Array(encrypted)")
				console.log(new Uint8Array(encrypted))
				console.log("btoa(new Uint8Array(encrypted))")
				console.log(btoa(new Uint8Array(encrypted)))
				console.log("arrayBufferToString(new Uint8Array(encrypted))")
				console.log(arrayBufferToString(new Uint8Array(encrypted)))
				console.log("btoa(arrayBufferToString(new Uint8Array(encrypted)))")
				console.log(btoa(arrayBufferToString(new Uint8Array(encrypted))))
				{* console.log("btoa(encrypted):" + btoa(encrypted)); *}
				{* console.log("btoa(arrayBufferToString(new Uint8Array(encrypted))): " + btoa(arrayBufferToString(new Uint8Array(encrypted)))); *}
				postData({link decrypt!}, { 'message': btoa(arrayBufferToString(new Uint8Array(encrypted))) }).then(data => {
					console.log(data);
				});
				{* window.crypto.subtle.decrypt( *}
			})
			.catch(function(err){
				console.error(err);
			});
		}).catch(function(err) {
			console.log(err);
		});

	});


{*
var message = "Hello World!";
var blinded = blind({ "message": message, "N": {$n}, "E": {$e} });


postData({link sign!}, { 'blinded': blinded })
  .then(data => {
    console.log(data); // JSON data parsed by `data.json()` call
	console.log("signed_64: "+ data.signed);
	let signed = atob(data.signed);
	console.log("signed: "+signed);
	var unblinded = unblind({ "signed": signed, "r": blinded.r, "N": {$n} });
	console.log(unblinded);
	console.log(unblinded.toString());
	postData({link decrypt!}, { "unblinded": unblinded, "message": message })
	.then(data => {
		console.log(data);
	});
  }); *}

	</script>

</head>
  <body>
  </body>
</html>
